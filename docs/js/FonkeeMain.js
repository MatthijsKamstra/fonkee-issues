// Generated by Haxe 4.1.5
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class FonkeeMain {
	constructor() {
		let _gthis = this;
		window.document.addEventListener("DOMContentLoaded",function(event) {
			$global.console.log("Fonkee Issues " + "üê°");
			_gthis.init();
		});
	}
	init() {
		util_Debug.debugFavicon();
		this.showEstimate();
	}
	showEstimate() {
		let codeEstimate = window.document.getElementById("code-estimate");
		let _gthis = this;
		if(codeEstimate == null) {
			return;
		}
		console.log("src/FonkeeMain.hx:26:","codeEstimate: " + Std.string(codeEstimate));
		window.fetch("data/estimate_2021.csv").then(function(response) {
			return response.text();
		}).then(function(data) {
			$global.console.log(data);
			_gthis.convertData(data);
		});
	}
	convertData(content) {
		let arr = thx_csv_Dsv.decode(content,thx_csv_Csv.decodeOptions);
		console.log("src/FonkeeMain.hx:40:",arr);
		let html = "<table class=\"table table-striped table-hover\">";
		html += "<thead>";
		let row = arr[0];
		html += "<tr>";
		html += "<th scope=\"col\">#</th>";
		let _g = 0;
		let _g1 = row.length;
		while(_g < _g1) {
			let j = _g++;
			let col = row[j];
			html += "<th scope=\"col\">" + col + "</th>";
		}
		html += "</tr>";
		html += "</thead>";
		html += "<tbody>";
		let _g2 = 1;
		let _g3 = arr.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let row = arr[i];
			html += "<tr>";
			html += "<th scope=\"row\">" + i + "</th>";
			let _g = 0;
			let _g1 = row.length;
			while(_g < _g1) {
				let j = _g++;
				let col = row[j];
				html += "<td>" + col + "</td>";
			}
			html += "</tr>";
		}
		html += "</tbody>";
		html += "</table>";
		let div = window.document.getElementById("code-estimate");
		div.innerHTML = html;
	}
	static main() {
		let app = new FonkeeMain();
	}
}
FonkeeMain.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
Math.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
}
Std.__name__ = true;
class StringBuf {
	constructor() {
		this.b = "";
	}
}
StringBuf.__name__ = true;
class StringTools {
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
}
StringTools.__name__ = true;
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"]
	,CFunction: {_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["v"],$_)
};
class haxe_CallStack {
	static callStack() {
		return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
	}
	static exceptionStack(fullStack) {
		if(fullStack == null) {
			fullStack = false;
		}
		let eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack());
		return fullStack ? eStack : haxe_CallStack.subtract(eStack,haxe_CallStack.callStack());
	}
	static toString(stack) {
		let b = new StringBuf();
		let _g = 0;
		let _g1 = stack;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			b.b += "\nCalled from ";
			haxe_CallStack.itemToString(b,s);
		}
		return b.b;
	}
	static subtract(this1,stack) {
		let startIndex = -1;
		let i = -1;
		while(++i < this1.length) {
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let j = _g++;
				if(haxe_CallStack.equalItems(this1[i],stack[j])) {
					if(startIndex < 0) {
						startIndex = i;
					}
					++i;
					if(i >= this1.length) {
						break;
					}
				} else {
					startIndex = -1;
				}
			}
			if(startIndex >= 0) {
				break;
			}
		}
		if(startIndex >= 0) {
			return this1.slice(0,startIndex);
		} else {
			return this1;
		}
	}
	static equalItems(item1,item2) {
		if(item1 == null) {
			if(item2 == null) {
				return true;
			} else {
				return false;
			}
		} else {
			switch(item1._hx_index) {
			case 0:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 0) {
					return true;
				} else {
					return false;
				}
				break;
			case 1:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 1) {
					let m1 = item1.m;
					let m2 = item2.m;
					return m1 == m2;
				} else {
					return false;
				}
				break;
			case 2:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 2) {
					let item11 = item1.s;
					let file1 = item1.file;
					let line1 = item1.line;
					let col1 = item1.column;
					let col2 = item2.column;
					let line2 = item2.line;
					let file2 = item2.file;
					let item21 = item2.s;
					if(file1 == file2 && line1 == line2 && col1 == col2) {
						return haxe_CallStack.equalItems(item11,item21);
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 3:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 3) {
					let class1 = item1.classname;
					let method1 = item1.method;
					let method2 = item2.method;
					let class2 = item2.classname;
					if(class1 == class2) {
						return method1 == method2;
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 4:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 4) {
					let v1 = item1.v;
					let v2 = item2.v;
					return v1 == v2;
				} else {
					return false;
				}
				break;
			}
		}
	}
	static itemToString(b,s) {
		switch(s._hx_index) {
		case 0:
			b.b += "a C function";
			break;
		case 1:
			let m = s.m;
			b.b += "module ";
			b.b += m == null ? "null" : "" + m;
			break;
		case 2:
			let col = s.column;
			let line = s.line;
			let file = s.file;
			let s1 = s.s;
			if(s1 != null) {
				haxe_CallStack.itemToString(b,s1);
				b.b += " (";
			}
			b.b += file == null ? "null" : "" + file;
			b.b += " line ";
			b.b += line == null ? "null" : "" + line;
			if(col != null) {
				b.b += " column ";
				b.b += col == null ? "null" : "" + col;
			}
			if(s1 != null) {
				b.b += ")";
			}
			break;
		case 3:
			let meth = s.method;
			let cname = s.classname;
			b.b += Std.string(cname == null ? "<unknown>" : cname);
			b.b += ".";
			b.b += meth == null ? "null" : "" + meth;
			break;
		case 4:
			let n = s.v;
			b.b += "local function #";
			b.b += n == null ? "null" : "" + n;
			break;
		}
	}
}
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
		this.__skipStack = 0;
		let old = Error.prepareStackTrace;
		Error.prepareStackTrace = function(e) { return e.stack; }
		if(((native) instanceof Error)) {
			this.stack = native.stack;
		} else {
			let e = null;
			if(Error.captureStackTrace) {
				Error.captureStackTrace(this,haxe_Exception);
				e = this;
			} else {
				e = new Error();
				if(typeof(e.stack) == "undefined") {
					try { throw e; } catch(_) {}
					this.__skipStack++;
				}
			}
			this.stack = e.stack;
		}
		Error.prepareStackTrace = old;
	}
	unwrap() {
		return this.__nativeException;
	}
	__shiftStack() {
		this.__skipStack++;
	}
	get_stack() {
		let _g = this.__exceptionStack;
		if(_g == null) {
			let value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			let s = _g;
			return s;
		}
	}
	setProperty(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
}
haxe_Exception.__name__ = true;
class haxe_NativeStackTrace {
	static saveStack(e) {
		haxe_NativeStackTrace.lastError = e;
	}
	static callStack() {
		let e = new Error("");
		let stack = haxe_NativeStackTrace.tryHaxeStack(e);
		if(typeof(stack) == "undefined") {
			try {
				throw e;
			} catch( _g ) {
			}
			stack = e.stack;
		}
		return haxe_NativeStackTrace.normalize(stack,2);
	}
	static exceptionStack() {
		return haxe_NativeStackTrace.normalize(haxe_NativeStackTrace.tryHaxeStack(haxe_NativeStackTrace.lastError));
	}
	static toHaxe(s,skip) {
		if(skip == null) {
			skip = 0;
		}
		if(s == null) {
			return [];
		} else if(typeof(s) == "string") {
			let stack = s.split("\n");
			if(stack[0] == "Error") {
				stack.shift();
			}
			let m = [];
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let i = _g++;
				if(skip > i) {
					continue;
				}
				let line = stack[i];
				let matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
				if(matched != null) {
					let path = matched[1].split(".");
					if(path[0] == "$hxClasses") {
						path.shift();
					}
					let meth = path.pop();
					let file = matched[2];
					let line = Std.parseInt(matched[3]);
					let column = Std.parseInt(matched[4]);
					m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line,column));
				} else {
					m.push(haxe_StackItem.Module(StringTools.trim(line)));
				}
			}
			return m;
		} else if(skip > 0 && Array.isArray(s)) {
			return s.slice(skip);
		} else {
			return s;
		}
	}
	static tryHaxeStack(e) {
		if(e == null) {
			return [];
		}
		let oldValue = Error.prepareStackTrace;
		Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
		let stack = e.stack;
		Error.prepareStackTrace = oldValue;
		return stack;
	}
	static prepareHxStackTrace(e,callsites) {
		let stack = [];
		let _g = 0;
		while(_g < callsites.length) {
			let site = callsites[_g];
			++_g;
			if(haxe_NativeStackTrace.wrapCallSite != null) {
				site = haxe_NativeStackTrace.wrapCallSite(site);
			}
			let method = null;
			let fullName = site.getFunctionName();
			if(fullName != null) {
				let idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					let className = fullName.substring(0,idx);
					let methodName = fullName.substring(idx + 1);
					method = haxe_StackItem.Method(className,methodName);
				} else {
					method = haxe_StackItem.Method(null,fullName);
				}
			}
			let fileName = site.getFileName();
			let fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
			if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
				fileName = fileName.substring(fileAddr + 6);
			}
			stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
		}
		return stack;
	}
	static normalize(stack,skipItems) {
		if(skipItems == null) {
			skipItems = 0;
		}
		if(Array.isArray(stack) && skipItems > 0) {
			return stack.slice(skipItems);
		} else if(typeof(stack) == "string") {
			switch(stack.substring(0,6)) {
			case "Error\n":case "Error:":
				++skipItems;
				break;
			default:
			}
			return haxe_NativeStackTrace.skipLines(stack,skipItems);
		} else {
			return stack;
		}
	}
	static skipLines(stack,skip,pos) {
		if(pos == null) {
			pos = 0;
		}
		if(skip > 0) {
			pos = stack.indexOf("\n",pos);
			if(pos < 0) {
				return "";
			} else {
				return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
			}
		} else {
			return stack.substring(pos);
		}
	}
}
haxe_NativeStackTrace.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
		this.__skipStack++;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let n = e.__constructs__[o._hx_index];
				let con = e[n];
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
class thx_Error extends Error {
	constructor(message,stack,pos) {
		super(message);
		this.message = message;
		if(null == stack) {
			try {
				stack = haxe_CallStack.exceptionStack();
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				stack = [];
			}
			if(stack.length == 0) {
				try {
					stack = haxe_CallStack.callStack();
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					stack = [];
				}
			}
		}
		this.stackItems = stack;
		this.pos = pos;
	}
	toString() {
		return this.message + "\nfrom: " + this.getPosition() + "\n\n" + this.stackToString();
	}
	getPosition() {
		return this.pos.className + "." + this.pos.methodName + "() at " + this.pos.lineNumber;
	}
	stackToString() {
		return haxe_CallStack.toString(this.stackItems);
	}
}
thx_Error.__name__ = true;
class thx_Strings {
	static trimCharsLeft(value,charlist) {
		let pos = 0;
		let _g = 0;
		let _g1 = value.length;
		while(_g < _g1) {
			let i = _g++;
			if(charlist.indexOf(value.charAt(i)) >= 0) {
				++pos;
			} else {
				break;
			}
		}
		return value.substring(pos);
	}
	static trimCharsRight(value,charlist) {
		let len = value.length;
		let pos = len;
		let i;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let j = _g++;
			i = len - j - 1;
			if(charlist.indexOf(value.charAt(i)) >= 0) {
				pos = i;
			} else {
				break;
			}
		}
		return value.substring(0,pos);
	}
}
thx_Strings.__name__ = true;
class thx_csv_Csv {
}
thx_csv_Csv.__name__ = true;
class thx_csv_Dsv {
	static decode(dsv,options) {
		if(null == options.quote) {
			options.quote = "\"";
		}
		if(null == options.escapedQuote) {
			options.escapedQuote = options.quote == "\"" ? "\"\"" : "\\" + options.quote;
		}
		if(null == options.trimValues) {
			options.trimValues = false;
		}
		if(null == options.trimEmptyLines) {
			options.trimEmptyLines = true;
		}
		if(options.trimEmptyLines) {
			dsv = thx_Strings.trimCharsRight(thx_Strings.trimCharsLeft(dsv,"\n\r"),"\n\r");
		}
		let result = dsv == "" ? [] : new thx_csv_core_Parser(options.delimiter,options.quote,options.escapedQuote).parse(dsv);
		if(options.trimValues) {
			let _g = 0;
			while(_g < result.length) {
				let row = result[_g];
				++_g;
				let _g1 = 0;
				let _g2 = row.length;
				while(_g1 < _g2) {
					let i = _g1++;
					row[i] = StringTools.trim(row[i]);
				}
			}
		}
		return result;
	}
}
thx_csv_Dsv.__name__ = true;
class thx_csv_core_Parser {
	constructor(delimiter,quote,escapedQuote) {
		this.delimiter = delimiter;
		this.quote = quote;
		this.escapedQuote = escapedQuote;
	}
	parse(s) {
		this.s = s;
		this.result = [];
		this.pos = 0;
		this.len = s.length;
		this.delimiterLength = this.delimiter.length;
		this.quoteLength = this.quote.length;
		this.escapedQuoteLength = this.escapedQuote.length;
		this.buffer = new StringBuf();
		this.row = [];
		try {
			let t;
			while(this.pos < this.len) if(this.s.substring(this.pos,this.pos + this.quoteLength) == this.quote && this.buffer.b.length == 0) {
				this.pos += this.quoteLength;
				while(this.pos < this.len) if(this.s.substring(this.pos,this.pos + this.escapedQuoteLength) == this.escapedQuote) {
					this.pushBuffer(this.quote);
					this.pos += this.escapedQuoteLength;
				} else if(this.s.substring(this.pos,this.pos + this.quoteLength) == this.quote) {
					this.pos += this.quoteLength;
					let next = this.s.substring(this.pos,this.pos + 1);
					while(next == " " || this.delimiter != "\t" && next == "\t") {
						++this.pos;
						next = this.s.substring(this.pos,this.pos + 1);
					}
					break;
				} else {
					this.pushBuffer(this.s.substring(this.pos,this.pos + 1));
					++this.pos;
				}
			} else if(this.s.substring(this.pos,this.pos + this.delimiterLength) == this.delimiter) {
				this.pushCell();
				this.pos += this.delimiterLength;
			} else {
				t = this.s.substring(this.pos,this.pos + 2);
				if(t == "\n\r" || t == "\r\n") {
					this.pos += 2;
					this.pushCell();
					this.pushRow();
					continue;
				}
				t = this.s.substring(this.pos,this.pos + 1);
				if(t == "\n" || t == "\r") {
					++this.pos;
					this.pushCell();
					this.pushRow();
					continue;
				}
				this.pushBuffer(this.s.substring(this.pos,this.pos + 1));
				++this.pos;
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let e = haxe_Exception.caught(_g).unwrap();
			console.log("thx/csv/core/Parser.hx:39:",e);
			throw new thx_Error("unable to parse at pos " + this.pos + ": " + Std.string(e),null,{ fileName : "thx/csv/core/Parser.hx", lineNumber : 40, className : "thx.csv.core.Parser", methodName : "parse"});
		}
		this.pushCell();
		this.pushRow();
		return this.result;
	}
	pushCell() {
		this.row.push(this.buffer.b);
		this.buffer = new StringBuf();
	}
	pushBuffer(char) {
		this.buffer.b += char == null ? "null" : "" + char;
	}
	pushRow() {
		this.result.push(this.row);
		this.row = [];
	}
}
thx_csv_core_Parser.__name__ = true;
class util_Debug {
	static debugFavicon() {
		if(window.location.href.indexOf("docs") != -1) {
			let title = window.document.title;
			window.document.title = "üêû " + title;
		}
	}
}
util_Debug.__name__ = true;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
thx_csv_Csv.decodeOptions = { delimiter : ",", quote : "\"", escapedQuote : "\"\"", trimValues : false, trimEmptyLines : true};
FonkeeMain.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=FonkeeMain.js.map